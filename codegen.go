package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"runtime/debug"

	"github.com/abakum/embed-encrypt/encryptedfs"
)

func generateCode(pkgName string, directives []directive) error {
	repo := ""
	if info, ok := debug.ReadBuildInfo(); ok {
		repo = info.Path
	}

	b := bytes.NewBuffer(nil)
	fmt.Fprintf(b, "// Code generated by https://%v; DO NOT EDIT.\n\n", repo)

	fmt.Fprintln(b, "package", pkgName)

	b.WriteString("import (")
	fmt.Fprintf(b, `"%v/encryptedfs"`+"\n", repo)
	lib, err := os.ReadFile(libEnc)
	if err == nil {
		fmt.Fprintf(b, "%q\n", lib)
	}
	if needsEmbed(directives) {
		b.WriteString(`"embed"`)
	} else {
		b.WriteString(`_ "embed"`)
	}
	b.WriteString(")\n")
	if err != nil {
		fmt.Fprintf(b, "//go:embed %v\n", keyEnc)
	}
	fmt.Fprintf(b, "var %s []byte\n", varKey)
	if err == nil {
		b.WriteString("func init(){\n")
		fmt.Fprintf(b, " %v\n", varLibFunc)
		b.WriteString("}\n")
	}

	for _, d := range directives {
		initCode(b, d)
	}

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		return err
	}

	return os.WriteFile("encrypted_fs.go", formatted, 0600)
}

func needsEmbed(directives []directive) bool {
	for _, d := range directives {
		if d.typ == "embed.FS" {
			return true
		}
	}

	return false
}

func initCode(b *bytes.Buffer, d directive) {
	fmt.Fprintf(b, "//go:embed %v\n", filesString(d.files))
	fmt.Fprintf(b, "var %vEnc %v\n", d.identifier, d.typ)

	b.WriteString("func init(){\n")
	switch d.typ {
	case "string":
		fmt.Fprintf(b, "%v = encryptedfs.DecString(%vEnc, %v)", d.identifier, d.identifier, varKey)
	case "[]byte":
		fmt.Fprintf(b, "%v = encryptedfs.DecByte(%vEnc, %v)", d.identifier, d.identifier, varKey)
	case "embed.FS":
		fmt.Fprintf(b, "%v = encryptedfs.InitFS(%vEnc, %v)", d.identifier, d.identifier, varKey)
	}

	b.WriteString("}\n")
}

func filesString(files []string) string {
	out := ""
	for _, file := range files {
		out += fmt.Sprintf("%q ", file+encryptedfs.ENC)
	}

	return out
}
